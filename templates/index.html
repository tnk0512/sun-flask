<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Tree Partition with CIELab Colors</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3-color.v1.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<style>
    .arc text {
        font: 10px sans-serif;
        text-anchor: middle;
    }
    .arc path {
        stroke: #fff;
    }
    .tooltip {
        position: absolute;
        visibility: hidden;
        background: #fff;
        border: 1px solid #ccc;
        padding: 5px;
        font-size: 12px;
    }
    .dimmed {
        opacity: 0.4;
    }
</style>
</head>
<body>
    <div class="tooltip" style="opacity: 0;"></div>
    <div id="nodeCount">Nodes displayed: 0</div>
    <div id="overview" style="position: absolute; top: 10px; right: 10px; width: 250px; height: 250px; border: 1px solid #ccc;"></div>
    <script>
        var width = 900,
            height = 760,
            maxradius = Math.min(width, height) / 2;

        var x = d3.scale.linear().range([0, 2 * Math.PI]);
        var y = d3.scale.linear().range([0, maxradius]);

        var partition = d3.layout.partition().value(function(d) { return d.value || 1; }).sort(null);

        var arc = d3.svg.arc()
            .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
            .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
            .innerRadius(function(d) { return Math.max(0, y(d.y)); })
            .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); });

        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + (width / 2) + "," + (height / 2) + ")");

        var tooltip = d3.select("body").append("div").attr("class", "tooltip");

        // 基準
        var sizeCriterion = 12; // クリック可能なノード
        var labelCriterion = 50; // ラベルを表示するノード

        function drawChart(root, clicked) {
            var nodes = partition.nodes(root);
            var maxdepth = d3.max(nodes, function(d) { return d.depth; });
            var levels = 5;

            if (clicked) {
                y.domain([0, maxdepth < levels ? 1 : levels / maxdepth]).range([20, maxradius]);
            } else {
                y.domain([0, maxdepth < levels ? 1 : levels / maxdepth]).range([0, maxradius]);
            }

            var initialNodes = nodes.filter(function(d) { return d.depth < levels; });

            var path = svg.selectAll("path").data(initialNodes).enter().append("path")
                .attr("d", arc)
                .style("fill", fillColor)
                .on("click", click)
                .on("mouseover", mouseover)
                .on("mouseout", mouseout);

            var text = svg.selectAll("text")
                .data(initialNodes.filter(function(d) {
                    var r = y(d.y + d.dy / 2); // Average radius of the arc
                    var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                    return r * theta >= labelCriterion;
                }))
                .enter().append("text")
                .attr("transform", function(d) {
                    return "translate(" + arc.centroid(d) + ")";
                })
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .text(function(d) {
                    return d.name;
                });

            updateNodeCount(initialNodes);
        }

        d3.json("/data", function(error, root) {
            if (error) throw error;
            drawChart(root, false);
        });

        function click(d) {
    svg.selectAll("text").style("visibility", "hidden");

    var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]);
    var yd = d3.interpolate(y.domain(), [d.y, 1]);
    var yr = d3.interpolate(y.range(), [20, maxradius]);

    // First animation with the current data
    svg.transition().duration(1000).tween("scale", function() {
        return function(t) {
            x.domain(xd(t));
            y.domain(yd(t)).range(yr(t));
        };
    }).selectAll("path").attrTween("d", function(d) { return function() { return arc(d); }; })
    .each("end", function(e, i) {
        if (i === 0) {
            x.domain([0, 1]); // Reset the x.domain
            // Fetch and update with new data
            $.ajax({
                url: "/subtree",
                type: "POST",
                contentType: "application/json",
                data: JSON.stringify({ target_name: d.name }),
                success: function(response) {
                    if (response.error) {
                        alert("Error: " + response.error);
                        return;
                    }

                    var subtree = response.subtree;
                    var parentNode = response.parent;
                    svg.selectAll("path").remove();
                    svg.selectAll("text").remove(); // Clear any remaining labels

                    var nodes = partition.nodes(subtree);
                    var maxdepth = d3.max(nodes, function(d) { return d.depth; });
                    var levels = 5;

                    y.domain([0, maxdepth < levels ? 1 : levels / maxdepth]).range([20, maxradius]);

                    var path = svg.selectAll("path").data(nodes).enter().append("path")
                        .attr("d", arc)
                        .style("fill", fillColor)
                        .on("click", click)
                        .on("mouseover", mouseover)
                        .on("mouseout", mouseout);

                    var text = svg.selectAll("text")
                        .data(nodes.filter(function(d) {
                            var r = y(d.y + d.dy / 2); // Average radius of the arc
                            var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                            return r * theta >= labelCriterion;
                        }))
                        .enter().append("text")
                        .attr("transform", function(d) {
                            return "translate(" + arc.centroid(d) + ")";
                        })
                        .attr("text-anchor", "middle")
                        .attr("font-size", "10px")
                        .text(function(d) {
                            return d.name;
                        });

                    // Add parent node in the center
                    if (parentNode) {
                        parentNode.depth = 0;
                        parentNode.x = 0;
                        parentNode.dx = 1;
                        parentNode.y = 0;
                        parentNode.dy = 1;
                        var parentY = d3.scale.linear().range([0, 20]);

                        var parentPath = svg.append("path")
                            .datum(parentNode)
                            .attr("d", function(d) {
                                var arcParent = d3.svg.arc()
                                    .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
                                    .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
                                    .innerRadius(function(d) { return Math.max(0, parentY(d.y)); })
                                    .outerRadius(function(d) { return Math.max(0, parentY(d.y + d.dy)); });
                                return arcParent(d);
                            })
                            .style("fill", "#fff")
                            .style("opacity", 1)  // 親ノードは不透明
                            .on("click", click)
                            .on("mouseover", mouseover)
                            .on("mouseout", mouseout);
                    }

                    updateNodeCount(nodes);
                },
                error: function(xhr, status, error) {
                    console.error("Error:", error);
                }
            });
        }
    });
}


        /*
        function click(d) {
    svg.selectAll("text").style("visibility", "hidden");

    var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]);
    var yd = d3.interpolate(y.domain(), [d.y, 1]);
    var yr = d3.interpolate(y.range(), [20, maxradius]);

    // First animation with the current data
    svg.transition().duration(1000).tween("scale", function() {
        return function(t) {
            x.domain(xd(t));
            y.domain(yd(t)).range(yr(t));
        };
    }).selectAll("path").attrTween("d", function(d) { return function() { return arc(d); }; })
    .each("end", function(e, i){
        if(i === 0){
            x.domain([0, 1]);
            // Log the x.domain and y.domain values
            svg.selectAll("path").remove();
            svg.selectAll("text").remove(); // Clear any remaining labels
            
        }
    });

    // Use setTimeout to wait for the duration of the transition (1000 ms)
    setTimeout(function() {
        // Fetch and update with new data
        $.ajax({
            url: "/subtree",
            type: "POST",
            contentType: "application/json",
            data: JSON.stringify({ target_name: d.name }),
            success: function(response) {
                if (response.error) {
                    alert("Error: " + response.error);
                    return;
                }

                var subtree = response.subtree;
                var parentNode = response.parent;
                //svg.selectAll("path").remove();
                //svg.selectAll("text").remove(); // Clear any remaining labels

                var nodes = partition.nodes(subtree);
                
                var maxdepth = d3.max(nodes, function(d) { return d.depth; });
                var levels = 5;

                y.domain([0, maxdepth < levels ? 1 : levels / maxdepth]).range([20, maxradius]);

                var path = svg.selectAll("path").data(nodes).enter().append("path")
                    .attr("d", arc)
                    .style("fill", fillColor)
                    .on("click", click)
                    .on("mouseover", mouseover)
                    .on("mouseout", mouseout);

                var text = svg.selectAll("text")
                    .data(nodes.filter(function(d) {
                        var r = y(d.y + d.dy / 2); // Average radius of the arc
                        var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                        return r * theta >= labelCriterion;
                    }))
                    .enter().append("text")
                    .attr("transform", function(d) {
                        return "translate(" + arc.centroid(d) + ")";
                    })
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .text(function(d) {
                        return d.name;
                    });

                // Add parent node in the center
                if (parentNode) {
                    parentNode.depth = 0;
                    parentNode.x = 0;
                    parentNode.dx = 1;
                    parentNode.y = 0;
                    parentNode.dy = 1;
                    var parentY = d3.scale.linear().range([0, 20]);

                    var parentPath = svg.append("path")
                        .datum(parentNode)
                        .attr("d", function(d) {
                            var arcParent = d3.svg.arc()
                                .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
                                .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
                                .innerRadius(function(d) { return Math.max(0, parentY(d.y)); })
                                .outerRadius(function(d) { return Math.max(0, parentY(d.y + d.dy)); });
                            return arcParent(d);
                        })
                        .style("fill", "#fff")
                        .style("opacity", 1)  // 親ノードは不透明
                        .on("click", click)
                        .on("mouseover", mouseover)
                        .on("mouseout", mouseout);
                }

                updateNodeCount(nodes);
                // Log the tree structure
                //console.log(formatTreeStructure(subtree));
            },
            error: function(xhr, status, error) {
                console.error("Error:", error);
            }
        });
    }, 1000); // Wait for the duration of the transition (1000 ms)
}*/

        // Function to format the tree structure for logging
        function formatTreeStructure(node, indent = "") {
           let structure = indent + node.name + "\n";
           if (node.children) {
               node.children.forEach(child => {
                   structure += formatTreeStructure(child, indent + "  ");
               });
           }
           return structure;}

        function fillColor(d) {
            let distance = y(d.y);
            let angle = x(d.x);
            let [L, a, b] = polarToCIELab(distance, angle, maxradius);
            return LabToHex(L, a, b);
        }

        function updateNodeCount(nodes) {
            var visibleNodes = nodes.filter(function(d) {
                return isNodeVisible(d, x.domain(), y.domain());
            });
            d3.select("#nodeCount").text("Number of visible nodes: " + visibleNodes.length);
        }

        function mouseover(d) {
            let nodeColor = d3.select(this).style("fill");
            let labColor = d3.lab(nodeColor);

            var r = y(d.y + d.dy / 2);
            var theta = x(d.x + d.dx) - x(d.x);
            var rTheta = r * theta;

            tooltip.style("visibility", "visible")
                .html(`Node: ${d.name}<br>r: ${r.toFixed(2)}, θ: ${theta.toFixed(2)}<br>r * θ: ${rTheta.toFixed(2)}<br>Color (CIELab): ${labColor.toString()}`);
        }

        function mouseout(d) {
            tooltip.style("visibility", "hidden");
        }

        svg.on("mousemove", function() {
            tooltip.style("top", (d3.event.pageY + 10) + "px")
                   .style("left", (d3.event.pageX + 10) + "px");
        });

        function polarToCIELab(distance, angle, maxDistance) {
            let L = 100 * (1 - 3 * distance / (4 * maxDistance));
            let a = 160 * distance / maxDistance * Math.cos(angle);
            let b = 160 * distance / maxDistance * Math.sin(angle);
            return [L, a, b];
        }

        function LabToHex(L, a, b) {
            let labColor = d3.lab(L, a, b);
            let rgbColor = labColor.rgb();
            return rgbColor.toString();
        }

        function isNodeVisible(d, xDomain, yDomain) {
            return d.x >= xDomain[0] && (d.x + d.dx) <= xDomain[1] && d.y >= yDomain[0] && (d.y + d.dy) <= yDomain[1];
        }
    </script>
</body>
</html>
