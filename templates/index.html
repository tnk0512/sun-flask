<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Tree Partition with CIELab Colors</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3-color.v1.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<style>
    .arc text {
        font: 10px sans-serif;
        text-anchor: middle;
    }
    .arc path {
        stroke: #fff;
    }
    .tooltip {
        position: absolute;
        visibility: hidden;
        background: #fff;
        border: 1px solid #ccc;
        padding: 5px;
        font-size: 12px;
    }
    .dimmed {
        opacity: 0.4;
    }
</style>
</head>
<body>
    <div class="tooltip" style="opacity: 0;"></div>
    <div id="nodeCount">Nodes displayed: 0</div>
    <div id="overview" style="position: absolute; top: 10px; right: 10px; width: 250px; height: 250px; border: 1px solid #ccc;"></div>
    <script>
        // Set up D3 layout and arc
        var width = 900,
            height = 760,
            maxradius = Math.min(width, height) / 2;
        
        var x = d3.scale.linear()
            .range([0, 2 * Math.PI]);
        
        var y = d3.scale.linear()
            .range([0, maxradius]);
        
        var partition = d3.layout.partition()
            .value(function(d) { return d.n; })
            .sort(null);
        
        var arc = d3.svg.arc()
            .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
            .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
            .innerRadius(function(d) { return Math.max(0, y(d.y)); })
            .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); });
        
        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + (width / 2) + "," + (height / 2) + ")");
        
        var tooltip = d3.select("body").append("div")
            .attr("class", "tooltip");

        // Fetch the initial data from the server
        d3.json("/data", function(error, root) {
            if (error) throw error;

            drawChart(root);
        });

        function drawChart(root) {
            var nodes = partition.nodes(root);
            // Calculate maxdepth from the dataset
            var maxdepth = d3.max(nodes, function(d) { return d.depth; });
        
            // Define the number of levels to display initially
            var levels = 5;
        
            // Adjust y-scale for initial nodes
            y.domain([0, levels / maxdepth]).range([0, maxradius]);
        
            // Filter initial nodes based on the specified number of levels
            var initialNodes = nodes.filter(function(d) { return d.depth < levels; });
        
            var path = svg.selectAll("path")
                .data(initialNodes)
                .enter().append("path")
                .attr("d", arc)
                .style("fill", fillColor);

            var sizeCriterion = 12;

            var nonClickablePaths = path.filter(function(d) {
                var r = y(d.y + d.dy / 2);
                var theta = x(d.x + d.dx) - x(d.x);
                return r * theta < sizeCriterion;
            });
        
            var clickablePaths = path.filter(function(d) {
                return !nonClickablePaths.data().includes(d);
            });
        
            clickablePaths.on("click", click)
                .on("mouseover", mouseover)
                .on("mouseout", mouseout);
        
            updateNodeCount(initialNodes);

            function click(d) {
                svg.selectAll("text").style("visibility", "hidden");
            
                $.ajax({
                    url: "/subtree",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({ target_name: d.name }),
                    success: function(response) {
                        if (response.error) {
                            alert("Error: " + response.error);
                            return;
                        }
            
                        var subtree = response.subtree;
                        var parentNode = response.parent;
            
                        // 新しいノードを処理
                        var newNodes = partition.nodes(subtree);
                        var newMaxdepth = d3.max(newNodes, function(d) { return d.depth; });
                        y.domain([0, newMaxdepth > levels ? levels / newMaxdepth : 1]).range([0, maxradius]);
            
                        svg.selectAll("path").remove();
                    
                        path = svg.selectAll("path")
                            .data(newNodes)
                            .enter().append("path")
                            .attr("d", arc)
                            .style("fill", fillColor)
                            .on("click", click)
                            .on("mouseover", mouseover)
                            .on("mouseout", mouseout);
                    
                        updateNodeCount(newNodes);
            
                        // 親ノードの処理（必要に応じて表示や操作を追加）
                        if (parentNode) {
                            console.log("Parent node:", parentNode);
                            // 親ノードに関する処理を追加（表示など）
                        }
                    },
                    error: function(xhr, status, error) {
                        console.error("Error:", error);
                    }
                });
            }

            function fillColor(d) {
                let distance = y(d.y);
                let angle = x(d.x);
                let [L, a, b] = polarToCIELab(distance, angle, maxradius);
                return LabToHex(L, a, b);
            }
        
            function mouseover(d) {
                let nodeColor = d3.select(this).style("fill");
                let labColor = d3.lab(nodeColor);
        
                var r = y(d.y + d.dy / 2);
                var theta = x(d.x + d.dx) - x(d.x);
                var rTheta = r * theta;
        
                tooltip.style("visibility", "visible")
                    .html(`Node: ${d.name}<br>r: ${r.toFixed(2)}, θ: ${theta.toFixed(2)}<br>r * θ: ${rTheta.toFixed(2)}<br>Color (CIELab): ${labColor.toString()}`);
            }
        
            function mouseout(d) {
                tooltip.style("visibility", "hidden");
            }
        
            svg.on("mousemove", function() {
                tooltip.style("top", (d3.event.pageY + 10) + "px")
                       .style("left", (d3.event.pageX + 10) + "px");
            });
        }
        
        function polarToCIELab(distance, angle, maxDistance) {
            let L = 100 * (1 - 3 * distance / (4 * maxDistance));
            let a = 160 * distance / maxDistance * Math.cos(angle);
            let b = 160 * distance / maxDistance * Math.sin(angle);
            return [L, a, b];
        }
        
        function LabToHex(L, a, b) {
            let labColor = d3.lab(L, a, b);
            let rgbColor = labColor.rgb();
            return rgbColor.toString();
        }
        
        function updateNodeCount(nodes) {
            var visibleNodes = nodes.filter(function(d) {
                return isNodeVisible(d, x.domain(), y.domain());
            });
            d3.select("#nodeCount").text("Number of visible nodes: " + visibleNodes.length);
        }

        function isNodeVisible(d, xDomain, yDomain) {
            return d.x >= xDomain[0] && (d.x + d.dx) <= xDomain[1] && d.y >= yDomain[0] && (d.y + d.dy) <= yDomain[1];
        }
    </script>
</body>
</html>

