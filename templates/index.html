<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Tree Partition with CIELab Colors</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3-color.v1.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<style>
    .arc text {
        font: 10px sans-serif;
        text-anchor: middle;
    }
    .arc path {
        stroke: #fff;
    }
    .tooltip {
        position: absolute;
        visibility: hidden;
        background: #fff;
        border: 1px solid #ccc;
        padding: 5px;
        font-size: 12px;
    }
    .dimmed {
        opacity: 0.4;
    }
</style>
</head>
<body>
    <div class="tooltip" style="opacity: 0;"></div>
    <div id="nodeCount">Nodes displayed: 0</div>
    <div id="overview" style="position: absolute; top: 10px; right: 10px; width: 250px; height: 250px; border: 1px solid #ccc;"></div>
    <script>
        // Set up D3 layout and arc
        var width = 900,
            height = 760,
            maxradius = Math.min(width, height) / 2;
        
        var x = d3.scale.linear()
            .range([0, 2 * Math.PI]);
        
        var y = d3.scale.linear()
            .range([0, maxradius]);
        
        var partition = d3.layout.partition()
            .value(function(d) { return d.value; })
            .sort(null);
        
        var arc = d3.svg.arc()
            .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
            .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
            .innerRadius(function(d) { return Math.max(0, y(d.y)); })
            .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); });
        
        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + (width / 2) + "," + (height / 2) + ")");
        
        var tooltip = d3.select("body").append("div")
            .attr("class", "tooltip");
        // 基準
        var sizeCriterion = 12; // クリック可能なノード
        var labelCriterion = 50; // ラベルを表示するノード


        // Draw the initial chart
        function drawChart(root, clicked) {
            var nodes = partition.nodes(root);
            var maxdepth = d3.max(nodes, function(d) { return d.depth; });
            var levels = 5;
            clicked? y.domain([0, maxdepth < levels ? 1 : levels / maxdepth]).range([20, maxradius]):y.domain([0, maxdepth < levels ? 1 : levels / maxdepth]).range([0, maxradius]);
            var initialNodes = nodes.filter(function(d) { return d.depth < levels; });

            var path = svg.selectAll("path")
                .data(initialNodes)
                .enter().append("path")
                .attr("d", arc)
                .style("fill", fillColor);

            var nonClickablePaths = path.filter(function(d) {
                var r = y(d.y + d.dy / 2);
                var theta = x(d.x + d.dx) - x(d.x);
                return r * theta < sizeCriterion;
            });

            var clickablePaths = path.filter(function(d) {
                return !nonClickablePaths.data().includes(d);
            });

            clickablePaths.on("click", click)
                .on("mouseover", mouseover)
                .on("mouseout", mouseout);

            // Initial label rendering
            var text = svg.selectAll("text")
                        .data(initialNodes.filter(function(d) {
                            var r = y(d.y + d.dy / 2); // Average radius of the arc
                            var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                            return r * theta >= labelCriterion;
                        }))
                        .enter().append("text")
                        .attr("transform", function(d) {
                            return "translate(" + arc.centroid(d) + ")";
                        })
                        .attr("text-anchor", "middle")
                        .attr("font-size", "10px")
                        .text(function(d) {
                            return d.name;
                        });

            updateNodeCount(initialNodes);
        }

        // Load the initial data
        d3.json("/data", function(error, root) {
            if (error) throw error;
            drawChart(root, false);
        });

        // Click function with initial animation and updating chart with new data
        function click(d) {
            svg.selectAll("text").style("visibility", "hidden");
            console.log("Clicked node:", d.name, d.x);

            // まず現在のデータでアニメーションを実行
            var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]);
            var yd = d3.interpolate(y.domain(), [d.y, 1]);
            var yr = d3.interpolate(y.range(), [20, maxradius]);

            svg.transition()
                .duration(1000)
                .tween("scale", function() {
                    return function(t) {
                        x.domain(xd(t));
                        y.domain(yd(t)).range(yr(t));
                    };
                })
                .selectAll("path")
                .attrTween("d", function(d) { return function() { return arc(d); }; })
                .styleTween("fill", function(d) {
                    let initialColor = d3.select(this).style("fill");
                    return function(t) {
                        return d3.interpolateLab(initialColor, fillColor(d))(t);
                    };
                })
                .each("end", function(e, i) {
                    if (i === 0) {
                        // アニメーションが完了したら新しいデータを取得して更新
                        $.ajax({
                            url: "/subtree",
                            type: "POST",
                            contentType: "application/json",
                            data: JSON.stringify({ target_name: d.name }),
                            success: function(response) {
                                if (response.error) {
                                    alert("Error: " + response.error);
                                    return;
                                }

                                var subtree = response.subtree;
                                var parentNode = response.parent;
                                var newNodes = partition.nodes(subtree);
                                var newMaxdepth = d3.max(newNodes, function(d) { return d.depth; });

                                // 各ノードのdy値を確認するためのログ
                                newNodes.forEach(function(node) {
                                    console.log(node.name, "x", node.x, "dx", node.dx);
                                });

                                svg.selectAll("path").remove();

                                var path = svg.selectAll("path")
                                    .data(newNodes)
                                    .enter().append("path")
                                    .attr("d", arc)
                                    .style("fill", fillColor)
                                    //.style("opacity", 0.6)  // 透明度を設定
                                    .on("click", click)
                                    .on("mouseover", mouseover)
                                    .on("mouseout", mouseout);

                                // 新しいデータの範囲を設定
                                var newY = d3.scale.linear().range([20, maxradius]);

                                path.transition()
                                    .duration(1000)
                                    .attrTween("d", function(d) {
                                        var arcNew = d3.svg.arc()
                                            .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
                                            .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
                                            .innerRadius(function(d) { return Math.max(0, newY(d.y)); })
                                            .outerRadius(function(d) { return Math.max(0, newY(d.y + d.dy)); });
                                        return function(t) {
                                            return arcNew(d);
                                        };
                                    });

                                updateNodeCount(newNodes);

                                // Show the new labels after the transition ends
                                svg.selectAll("text").remove(); // Clear any remaining labels
                                var text = svg.selectAll("text")
                                    .data(newNodes.filter(function(d) {
                                        var r = y(d.y + d.dy / 2); // Average radius of the arc
                                        var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                                        return r * theta >= labelCriterion;
                                    }))
                                    .enter().append("text")
                                    .attr("transform", function(d) {
                                        return "translate(" + arc.centroid(d) + ")";
                                    })
                                    .attr("text-anchor", "middle")
                                    .attr("font-size", "10px")
                                    .text(function(d) {
                                        return d.name;
                                    })
                                    .style("visibility", function(d) {
                                        return isNodeVisible(d, x.domain(), y.domain()) ? "visible" : "hidden";
                                    });

                                // Add clickable parent node in the center
                                if (parentNode) {
                                    parentNode.depth = 0;
                                    parentNode.x = 0;
                                    parentNode.dx = 1;
                                    parentNode.y = 0;
                                    parentNode.dy = 1;

                                    var parentY = d3.scale.linear().range([0, 20]);

                                    var parentPath = svg.append("path")
                                        .datum(parentNode)
                                        .attr("d", function(d) {
                                            var arcParent = d3.svg.arc()
                                                .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
                                                .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
                                                .innerRadius(function(d) { return Math.max(0, parentY(d.y)); })
                                                .outerRadius(function(d) { return Math.max(0, parentY(d.y + d.dy)); });
                                            return arcParent(d);
                                        })
                                        .style("fill", "#fff")
                                        .style("opacity", 1)  // 親ノードは不透明
                                        .on("click", click)
                                        .on("mouseover", mouseover)
                                        .on("mouseout", mouseout);
                                }
                            },
                            error: function(xhr, status, error) {
                                console.error("Error:", error);
                            }
                        });
                    }
                });
        }

        function fillColor(d) {
            let distance = y(d.y);
            let angle = x(d.x);
            let [L, a, b] = polarToCIELab(distance, angle, maxradius);
            return LabToHex(L, a, b);
        }

        function updateNodeCount(nodes) {
            var visibleNodes = nodes.filter(function(d) {
                return isNodeVisible(d, x.domain(), y.domain());
            });
            d3.select("#nodeCount").text("Number of visible nodes: " + visibleNodes.length);
        }

        function isDescendantOrSelf(node, ancestor) {
            if (node === ancestor) return true;
            while (node.parent) {
                node = node.parent;
                if (node === ancestor) return true;
            }
            return false;
        }

        function mouseover(d) {
            let nodeColor = d3.select(this).style("fill");
            let labColor = d3.lab(nodeColor);

            var r = y(d.y + d.dy / 2);
            var theta = x(d.x + d.dx) - x(d.x);
            var rTheta = r * theta;

            tooltip.style("visibility", "visible")
                .html(`Node: ${d.name}<br>r: ${r.toFixed(2)}, θ: ${theta.toFixed(2)}<br>r * θ: ${rTheta.toFixed(2)}<br>Color (CIELab): ${labColor.toString()}`);
        }

        function mouseout(d) {
            tooltip.style("visibility", "hidden");
        }

        svg.on("mousemove", function() {
            tooltip.style("top", (d3.event.pageY + 10) + "px")
                   .style("left", (d3.event.pageX + 10) + "px");
        });

        function polarToCIELab(distance, angle, maxDistance) {
            let L = 100 * (1 - 3 * distance / (4 * maxDistance));
            let a = 160 * distance / maxDistance * Math.cos(angle);
            let b = 160 * distance / maxDistance * Math.sin(angle);
            return [L, a, b];
        }

        function LabToHex(L, a, b) {
            let labColor = d3.lab(L, a, b);
            let rgbColor = labColor.rgb();
            return rgbColor.toString();
        }

        function isNodeVisible(d, xDomain, yDomain) {
            return d.x >= xDomain[0] && (d.x + d.dx) <= xDomain[1] && d.y >= yDomain[0] && (d.y + d.dy) <= yDomain[1];
        }
    </script>
</body>
</html>
